<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阅读计划100天]]></title>
    <url>%2FSteveJeson%2F2019%2F02%2F21%2F%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92100%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1This is code area.]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令整理]]></title>
    <url>%2FSteveJeson%2F2019%2F02%2F21%2FGit%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Git命令大全1、配置Git1234567## 安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot;## 获取Git配置信息git config --list## 生成SSHssh-keygen -t rsa -C &quot;youremail@example.com&quot; 2、创建版本库和提交代码123456789101112131415161718192021## 初始化一个git仓库git init## 关联(添加)远程库地址（可关联多个）git remote add 别名 地址git remote add origin http://host/repository/myproject.git ## 查看仓库状态git status## 将所有修改添加到暂存区git add .## Ant风格添加修改git add *## 将以Controller结尾的文件的所有修改添加到暂存区git add *Controller ## 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.javagit add Hello* ## 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java ## 如果是HelloGit.txt或者Hello.java是不会被添加的git add Hello?## 将暂存区的修改提交到仓库git commit -m &quot;comment&quot; ## 将工作区的修改提交到仓库，相当于git add . 与 git commit -m &quot;comment&quot;的合体git commit –am &quot;comment&quot; 或 git commit –a –m &quot;comment&quot; 3、本地和远程的同步123456789101112131415161718192021222324## 查看远程库地址信息git remote -v## 查看远程库origin状态git remote show origin## 修改关联的远程库地址 git remote set-url 别名 地址git remote set-url origin http://192.168.1.161/ddc/ddcsz.git## 删除关联的远程库地址git remote rm origin## 推送本地库代码到远程库git push -u origin master //推送本地代码到origin库的master分支，origin为关联地址时写的别名## 从远程的origin仓库的master分支下载代码到本地的origin mastergit fetch origin master## 从远程origin仓库的master分支下载代码到本地temp分支，如果temp分支不存在则会新建一个；不会自动合并git fetch origin master:temp## 如果不加参数，则取回所有分支的更新git fetch## 取回远程next分支，与本地master分支合并；相当于先git fetch再git mergegit pull origin next:master## 如果远程next分支要与当前分支合并，则可以省略冒号部分git pull origin next## 当前分支自动与唯一一个追踪分支进行合并git pull## 手动建立追踪(关联)关系：指定本地当前所在分支追踪远程next分支git branch --set-upstream-to origin/next 4、分支管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849## 新建分支git branch dev## 重命名分支git branch -m old_local_branch_name new_local_branch_name## 切换到分支git checkout dev## 新建+切换分支git checkout -b dev## 新建+切换分支+关联远程分支git checkout -b dev origin/dev## 推送本地分支到远程库git push origin dev## Fast forward模式合并dev分支到当前分支,不记录本次操作git merge dev## Fast forward模式合并远程dev分支到当前分支git merge origin/dev## 禁用Fast forward模式，合并dev分支到当前分支，幷记录本次操作;如果不使用-m参数git merge --no-ff -m “Merge branch dev” dev## 查看本地分支git branch## 查看遠程分支git branch -r## 查看包括本地和远程所有的分支git branch -a## 查看各个分支最后一个提交对象的信息git branch -v## 查看各个分支对应的远程分支及最后一个提交对象的信息git branch -vv## 查看哪些分支被幷入当前分支git branch --merged## 查看尚未与当前分支合并的分支git branch --no-merged## 删除本地dev分支git branch -d dev## 强制删除本地dev分支git branch -D dev## 删除本地对应的远程分支git branch -r -d origin/dev## 远程删除git服务器上的分支git push origin -d devgit push origin --delete dev## 将当前分支的修改打成补丁，以develop最近一次提交作为基础，然后将补丁运用上去git rebase develop## 放弃本次rebase过程，回到初始状态git rebase --abort## 跳过本次补丁运用git rebase --skip## 继续运用补丁git rebase --continue 5、查看日志1234567891011121314151617181920212223242526272829303132333435363738## 以默认格式输出日志git log## 将每条日志输出为一行git log --oneline## 指定显示最近多少条日志 git log -[length]git log --oneline -2## 指定跳过前几条日志 git log --skip=[skip]git log --skip=1 -2 --oneline## 显示更多提交信息，包括提交ID，文件树ID，父提交ID，作者和提交者git log –pretty=raw## 显示提交的具体改动记录，相当于多次使用git show [commit_id]git log -p## 仅查看哪些文件有改动git log --stat## 比较本地仓库和远程仓库的区别git log -p master.. origin/master## 绘制提交线索，有合并也会显示git log --graph --oneline## 显示合并过程，简略提交信息git log --graph --pretty=oneline --abbrev-commit## 显示一些相关的信息，如HEAD、分支名、tag名等git log --decorate --oneline## 显示每次提交对应的文件改动git log --name-status --oneline## 通过作者搜索提交日志,yourname可以包含通配符git log --author yourname## 通过提交关键字搜索日志git log --grep keywords## 以上两者组合使用搜索日志git log --author yourname --grep keywords## 查看最近提交的taggit describe## 查看各种对象的详细情况git show [commit_id|tag_name|branch_name|...]## 查看某个文件的历史修改情况git blame [file_path]## 查看分支操作记录git reflog 6、标签(tag)的使用1234567891011121314151617181920212223## 创建轻量标签：不需要传递参数，指定标签名即可git tag v1.0.0## 创建附注标签：参数-a即annotated的缩写，指定标签类型，后附标签名。参数m指定标签说## 明，说明信息会保存在标签对象中git tag -a v1.0.0 -m &quot;标签说明&quot;## 列出当前仓库的所有标签git tag## 列出符合模式的标签git tag -l &apos;v1.0.*&apos;## 查看标签版本信息git show v1.0.0## 切换到标签git checkout v1.0.0## 删除本地标签 git tag -d v1.0.0 ## 删除远程库标签git push origin :refs/tags/v1.0.0## 给指定的commit打标签git tag -a v1.0.1 [commit_id] -m &quot;打标签测试&quot;## 将指定标签提交到git服务器git push origin v1.0.0## 将本地所有标签一次性提交到git服务器git push origin –-tags 7、比较修改文件1234567891011121314151617181920212223242526272829## 工作区与暂存区比较git diff filepath## 工作区与HEAD(当前版本)比较git diff HEAD -- filepath## 暂存区与HEAD比较git diff --staged filepath 或者 git diff --cached filepath## 当前分支的文件与branchName 分支的文件进行比较git diff branchName filepath## 两个提交版本之间的比较 git diff commitId1 commitId2## 与某一次提交的某个文件夹或者文件进行比较git diff commitId filepath ## 两个版本的src文件夹或者文件的比较git diff commitId1 commitId2 src# 使用 git diff 打补丁## patch的命名是随意的，不加其他参数时作用是当我们希望将本仓库工作区的修改拷贝一份到其他机器上使用，## 但是修改的文件比较多，拷贝量比较大，此时我们可以将修改的代码做成补丁，之后在其他机器上对应目录下使用 ## git apply patch 将补丁打上即可git diff &gt; patch## 运用补丁git apply patch## 两个commit间的修改（包含两个commit）（带提交信息）git format-patch commitId1 commitId2## 单个commit（带提交信息）git format-patch -1 commitId## 从某commit以来的修改（不包含该commit）git format-patch commitId## 生成xxx.rej冲突文件，不带提交信息，需要重新提交git apply --reject *.patch 8、撤销修改和版本回退12345678910111213141516171819## 修改上次提交信息git commit --amend## 撤销暂存区的修改，重新放回工作区git reset HEAD [file_path]## 丢弃工作区的修改，恢复到修改前的版本状态git checkout -- [file_path]## 撤销所有修改文件git reset --hard## 撤销已提交到本地仓库但是还未推送到远程的文件git reset --hard origin/master## 回退到上一个版本(注：git中的HEAD指当前版本，上一个加上^表示，上上个用两个^，3个## 用HEAD~3，以此类推)git reset --hard HEAD^## 回退到指定版本git reset --hard [commit_id]## 以上命令hard参数可以被替换为soft和mixed参数git reset --hard //版本和状态一起回退，并删除回退点之前的信息，回退的比较彻底干净git reset --soft //版本和状态一起回退，但是会保留回退点之前的信息git reset --mixed //版本回退，但是会保留回退点之前的状态和信息，为默认操作 9、储藏(stash)12345678910111213141516## 储藏当前所有修改，让工作区变得干净git stash save [description]## 查看现有的stash储藏列表git stash list## 重新应用指定储藏,不加参数则默认第一个git stash apply [stash@&#123;id&#125;] //id可通过list命令查看## 重新应用第一个stash,并删除git stash pop## 重新应用指定stash，并删除git stash pop [stash@&#123;id&#125;]## 清空stash列表git stash clear## 删除指定stashgit stash drop [stash@&#123;id&#125;]## 基于stash创建分支，创建成功则会删除stashgit stash branch [branch_name] 10、删除1234567891011121314## 更新远程库对象时删除没用的对象git fetch origin --prune## 删除远程库没用的对象git remote prune origin## 删除未跟踪(没有添加到暂存区)的文件git clean -f [file_path]## 删除未跟踪的目录及文件git clean -df [dir_path]## 删除所有未跟踪的目录及文件git clean -xdf## 显示即将要删除的目录和文件git clean -n## 移除项目的版本控制(删除.git文件)rm -rf .git 11、跟踪处理12345678## 忽略已跟踪的文件git update-index --assume-unchanged [file_path]## 恢复跟踪git update-index --no-assume-unchanged [file_path]## 取消某个文件跟踪，使之成为未跟踪状态git rm -f --cached [file_path] ## 取消某个文件目录跟踪，使之成为未跟踪状态git rm -r --cached [dir_path]]]></content>
      <tags>
        <tag>-Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[search]]></title>
    <url>%2FSteveJeson%2F2019%2F02%2F21%2Fsearch%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FSteveJeson%2F2019%2F02%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
